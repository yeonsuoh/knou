# 2강. 배열

## 1. 배열의 정의

* 개발자가 알고 있는 인덱스 값은 추상화된 값
* 메모리의 주소값은 실제 물리적인 위치값(주소값)
* 운영체제는 접근하려는 원소의 인덱스를 이용하여 실제 메모리 주소를 계산
* 배열은 추상화된 의미와 구체화된 의미가 같은 자료구조

## 2. 배열의 추상 자료형
* 배열은 인덱스(i)와 값(e)의 쌍으로 이루어져 있다.
* create(n): n개의 원소들을 저장할 수 있는 공백 배열 생성
* retrieve(a, i): 배열 a와 인덱스 i를 매개변수로 전달받아 인덱스 i의 위치에 대응되는 원소값 e가 있다면 원소값 e를 반환하고 그렇지 않은 경우 에러 메시지를 반환
* store(a, i, e): 배열 a와 인덱스 i, 원소값 e를 매개변수로 번달받아 Index를 검사하여 i 값이 유효할 경우 <i, e> 쌍이 되게 원소값을 i번째 인덱스에 저장하고 배열 e를 반환

## 3. 배열의 연산의 구현
* c언어
### create
```
void create(int n) {
    int a[n];
    int i;
    for (i=0, i<n, i++) {
        a[i] = 0;
    }
 }
```
### retrieve
```
#define array_size 5
int retrieve(int *a, int i) {
    if (i >= 0 && i < array_size) return a[i];
    else { printf("Error \n");
        return (-1); }
 }
```
### store
```
#define array_size 5
int retrieve(int *a, int i, int e) {
    if (i >= 0 && i < array_size) 
        a[i] = e;
    else printf("Error \n");
 }
```

## 4. 1차원 배열
* 배열의 첫 번째 원소 A[0]의 메모리 시작 주소를 A(L)이라고 하고 각 자료형의 크기 k를 알면 간단한 계산에 의해서 A[i]의 주소를 알 수 있다.
* A[]의 크기를 k라고 가정하면, A[i]의 저장 주소는 a + i * k

## 5. 배열의 확장

### 2차원 배열
* 행렬은 2차원 배열과 생김새가 비슷

### 행 우선 저장 방식
* 하나의 행을 연속적으로 메모리에 할당하고, 그다음 행을 메모리 영역에 할당하는 방법
* A[][]는 A[m][n], m은 행, n은 열

### 열 우선 저장 방식
* 하나의 열을 연속적으로 메모리에 할당하고, 그 다음 열을 메모리 영역에 할당하는 방법

>행 우선 , 열 우선 순서 다채원 배열은 프로그래밍 언어에 따라 결정된다. (c - 행우선)

## 6. 희소행렬의 개념
* 희소행렬(sparse matrix) : 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬
* 희소행렬은 0은 저장하지 않고, 0이 아닌 원소를 (행번호, 열번호, 원소값)의 형태로 나타낸다.
* 희소행렬에서 첫 번째 행은 행 번호와 열 번호를 나타내는 것으로, 표현하려는 희소행렬의 행 크기와 열 크기를 나타낸다.