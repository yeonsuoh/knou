# 5강. 알고리즘(1) 

# 제3장 알고리즘

## 3.1 알고리즘의 개념

### 3.1.1 알고리즘의 정의
* 알고리즘 : 주어진 문제에 대해서 하나 이상의 결과를 생성하기 위해 모호함이 없는 간단하고 컴퓨터가 수행 가능한 일련의 유한개의 명령을 순서에 따라 구성한 것
  * 입출력
  * 명확성
  * 유한성
  * 유효성
  * (실용적 관점 -> 효율성)

### 3.1.2 알고리즘 생성 단계
* 알고리즘 설계 -> 알고리즘 표현/기술 -> 정확성 검증 -> 효율성 분석
* 표현/기술 방법 : 자연어, 순서도, 프로그래밍 언어, 의사코드


### 3.1.3 자료구조와 알고리즘의 관계
* 프로그램 = 자료구조 + 알고리즘

## 3.2 알고리즘의 설계

### 3.2.1 분할정복 방법 (divide and conquer)
* 순환적으로 문제를 푸는 방법
* 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제로 순환적으로(recursively) 분할하고, 분할된 문제들을 각각 해결한 후 해를 결합하여 원래 문제의 해를 구하는 하향식 접근방법
* 분할(divide) : 주어진 문제를 여러 개의 작은 문제로 분할
* 정복(conquer) : 작은 문제들을 순환적으로 분할한다. 만약 작은 문제가 더 이상 분할되지 않을 정도로 충분히 작다면 작은 문제의 해를 구한다.
* 결합(combine) : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.
* 분할된 작은 문제들은 서로 독립적
* 이진 탐색
* 정렬 알고리즘 - 퀵 정렬, 합병 정렬

### 3.2.2 동적 프로그래밍 방법 (dynamic programming)
* 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장해 놓고, 이를 이용하여 입력 크기가 보다 큰 원래 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법
* 모든 정점 간의 최단 경로를 구하는 플로이드 알고리즘

### 3.2.3 욕심쟁이 방법 (greedy)
* 전후 단계의 선택과는 상관없이 어떤 기준에 따라 각 단계마다 '가장 최선'이라고 여겨지는 국부적인(local) 최적해를 선택해 나가면 결과적으로 전체적인(global) 최적해를 구할 수 있다고 희망하는 방법
* 거스름돈 문제, 배낭 문제

## 3.3 알고리즘의 분석

### 3.3.1 정확성 분석
* 유효한 입력에 대해 유한 시간 내에 정확한 결과를 생성하는지를 증명

### 3.3.2 효율성 분석
* 공간 복잡도(메모리 양)
* 시간 복잡도(수행 시간)
  * 알고리즘에서 수행되는 단위 연산의 수행 횟수의 합 
  * 입력 크기의 함수로 표현, 최악의 수행 시간을 사용 

### 3.3.3 점근성능
* 입력 크기가 충분히 커짐에 따라 결정되는 성능 -> 다항식으로 표현된 수행 시간의 함수에서 계수 없이 최고차항만을 취해서 표현
* 표기법
  * 점근적 상한 O
  * 점근적 하한 오메가
  * 점근적 상하한 세타

## 3.4 정렬 알고리즘

### 3.4.1 선택 정렬
* 주어진 데이터 중에서 가장 작은 키값을 갖는 데이터를 선택하여 차례대로 나열
* 최악/최선/평균 수행 시간이 언제나 동일

### 3.4.2 버블 정렬
* 주어진 배열의 왼쪽에서부터 오른쪽 끝까지 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽의 값이 더 큰 경우에는 오른쪽의 값과 자리를 바꾸는 과정을 반복해서 정렬하는 방법
* 데이터 입력 순서에 민감 -> 최악 O(n2), 최선 O(n)

### 3.4.3 삽입 정렬
* 입력 배열을 정렬된 부분과 미정렬 부분으로 구분하고, 미정렬 부분에서 첫 번째 원소를 뽑은 후 정렬된 부분에서 제자리를 찾아서 데이터를 삽입
* 데이터 입력 순서에 민감 -> 최악 O(n2), 최선 O(n)

# 6강. 알고리즘(2)

### 3.4.4 퀵 정렬
* 피벗, 분할 과정
* 분할 정복 방법
* 피벗으로 선택되는 값에 따른 부분배열로의 분할 비율의 차이에 의해 성능이 달라짐
* 피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 높음
* 최악 O(n2), 최선/평균 O(nlogn)

### 3.4.5 합병 정렬
* 합병 과정, 분할정복 방법
* 성능은 항상 O(nlogn)

## 3.5 탐색 알고리즘

### 3.5.1 순차 탐색
* 아무런 순서 없이 단순히 연속적으로 저장된 데이터 탐색에 적합 -> O(n)

### 3.5.2 이진 탐색
* 정렬된 데이터에 대해서 적용 가능
* 탐색을 수행할 때마다 탐색 대상이 되는 데이터를 절반씩 줄여 가면서 원하는 값을 찾는 방법
* O(logn)
* 삽입/삭제와 같은 동적 연산이 많은 응용 분야에는 적합하지 않다. 

### 3.5.3 이진 탐색 트리
* (1) 탐색
  * 최선 및 평균 탐색 시간 : O(logn)
* (2) 삽입
* (3) 삭제
  * 후속자 노드 : 어떤 노드의 키값 바로 다음 키값
  * 자식 노드가 없다면 위치 조절은 필요 없음
  * 자식 노드가 하나 있다면 삭제하며 서브트리 전체를 따라 올리기
  * 자식 노드가 2개 모두 있다면 삭제되는 노드의 후속자 노드를 삭제 노드의 위치로 올리고, 후속자 노드를 삭제 노드로 취급하여 후속자 노드의 자식 노드의 개수에 따라 다시 삭제 연산 처리
* (4) 문제점
  * 경사 이진트리가 형성되는 경우 탐색 과정에서 최대 n번의 노드를 비교해야 하므로, 최악의 탐색 시간 O(n)을 갖는다.