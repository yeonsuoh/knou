# 5강. 알고리즘(1) 

# 제3장 알고리즘

## 3.1 알고리즘의 개념

### 3.1.1 알고리즘의 정의
* 알고리즘 : 주어진 문제에 대해서 하나 이상의 결과를 생성하기 위해 모호함이 없는 간단하고 컴퓨터가 수행 가능한 일련의 유한개의 명령을 순서에 따라 구성한 것
  * 입출력
  * 명확성
  * 유한성
  * 유효성
  * (실용적 관점 -> 효율성)

### 3.1.2 알고리즘 생성 단계
* 알고리즘 설계 -> 알고리즘 표현/기술 -> 정확성 검증 -> 효율성 분석
* 표현/기술 방법 : 자연어, 순서도, 프로그래밍 언어, 의사코드


### 3.1.3 자료구조와 알고리즘의 관계
* 프로그램 = 자료구조 + 알고리즘

## 3.2 알고리즘의 설계

### 3.2.1 분할정복 방법 (divide and conquer)
* 순환적으로 문제를 푸는 방법
* 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제로 순환적으로(recursively) 분할하고, 분할된 문제들을 각각 해결한 후 해를 결합하여 원래 문제의 해를 구하는 하향식 접근방법
* 분할(divide) : 주어진 문제를 여러 개의 작은 문제로 분할
* 정복(conquer) : 작은 문제들을 순환적으로 분할한다. 만약 작은 문제가 더 이상 분할되지 않을 정도로 충분히 작다면 작은 문제의 해를 구한다.
* 결합(combine) : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.
* 분할된 작은 문제들은 서로 독립적
* 이진 탐색
* 정렬 알고리즘 - 퀵 정렬, 합병 정렬

### 3.2.2 동적 프로그래밍 방법 (dynamic programming)
* 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장해 놓고, 이를 이용하여 입력 크기가 보다 큰 원래 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법
* 모든 정점 간의 최단 경로를 구하는 플로이드 알고리즘

### 3.2.3 욕심쟁이 방법 (greedy)
* 전후 단계의 선택과는 상관없이 어떤 기준에 따라 각 단계마다 '가장 최선'이라고 여겨지는 국부적인(local) 최적해를 선택해 나가면 결과적으로 전체적인(global) 최적해를 구할 수 있다고 희망하는 방법
* 거스름돈 문제, 배낭 문제

## 3.3 알고리즘의 분석

### 3.3.1 정확성 분석
* 유효한 입력에 대해 유한 시간 내에 정확한 결과를 생성하는지를 증명

### 3.3.2 효율성 분석
* 공간 복잡도(메모리 양)
* 시간 복잡도(수행 시간)
  * 알고리즘에서 수행되는 단위 연산의 수행 횟수의 합 
  * 입력 크기의 합수로 표현, 최악의 수행 시간을 사용 

### 3.3.3 점근성능
* 입력 크기가 충분히 커짐에 따라 결정되는 성능 -> 다항식으로 표현된 수행 시간의 함수에서 계수 없이 최고차항만을 취해서 표현
* 표기법
  * 점근적 상한 O
  * 점근적 하한 오메가
  * 점근적 상하한 세타

## 3.4 정렬 알고리즘

### 3.4.1 선택 정렬
* 주어진 데이터 중에서 가장 작은 키값을 갖는 데이터를 선택하여 차례대로 나열
* 최악/최선/평균 수행 시간이 언제나 동일

### 3.4.2 버블 정렬
* 주어진 배열의 왼쪽에서부터 오른쪽 끝까지 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽의 값이 더 큰 경우에는 오른쪽의 값과 자리를 바꾸는 과정을 반복해서 정렬하는 방법
* 데이터 입력 순서에 민감 -> 최악 O(n2), 최선 O(n)

### 3.4.3 삽입 정렬
* 입력 배열을 정렬된 부분과 미정렬 부분으로 구분하고, 미정렬 부분에서 첫 번째 원소를 뽑은 후 정렬된 부분에서 제자리를 찾아서 데이터를 삽입
* 데이터 입력 순서에 민감 -> 최악 O(n2), 최선 O(n)
 