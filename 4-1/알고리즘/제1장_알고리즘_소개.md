# 1. 알고리즘 소개

## 1.1 기본 개념
* 알고리즘 : 
  * 주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정 (음식을 만들기 위한 조리법)
  * 주어진 문제를 해결하거나 함수를 계산하기 위해 따라야 할 명령어들을 단계적으로 나열한 것
  * (입출력) : 0개 이상 외부 입력, 1개 이상 출력
  * (명확성) : 각 명령은 모호하지 않고 단순 명확
  * (유한성) : 한정된 수의 단계를 거친 후에는 반드시 종료함
  * (유효성) : 모든 명령은 컴퓨터에서 수행 가능
  * 실용적 관점 -> (효율성) : 알고리즘은 효율적이어야 함 

## 1.2 알고리즘 설계
* 알고리즘 생성 단계 : 설계 -> 표현/기술 -> 정확성 검증 -> 효율성 분석
* 알고리즘 설계는 주어지는 문제와 조건 등에 따라 매우 다양 -> 범용적 개념의 설계기법은 존재하지 않음
* 비교적 간단, 많은 부류의 문제에서 사용 가능한 대표적인 설계기법 -> 욕심쟁이, 분할정복, 동적 프로그래밍

### 1.2.1 욕심쟁이 방법 greedy
* 해를 구하는 일련의 선택 과정에서 전후 단계의 선택과는 상관없이 각 단계마다 ‘가장 최선’이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법
* 최솟값, 최댓값 찾는 최적해 문제에 주로 사용
* 거스름돈, 배낭 문제
* 동전의 액면가가 일반적인 경우 욕심쟁이 방법으로 해결 불가
* 물체를 쪼갤 수 없는 배낭 문제는 0/1 배낭 문제라고 하며 이는 욕심쟁이 방법으로 해결 불가 -> 7장 NP-완전 문제 

### 1.2.2 분할정복 방법 divide-and-conquer
* 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제들로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후, 이들의 해를 결합하여 원래 문제의 해를 구하는 방식
* 특징
  * 분할된 작은 문제는 원래 문제와 동일
  * 분할된 문제는 서로 독립적
* 퀵 정렬, 합병 정렬, 이진 탐색 등

### 1.2.3 동적 프로그래밍 dynamic programming
* 입력의 크기가 가장 작은 부분 문제부터 해를 구하여 테이블에 저장해 놓고, 이를 이용해서 입력 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 상향식 bottom-up 접근 방법
* 특징
  * 각각의 작은 문제는 원래 문제와 동일, 입력의 크기만 작음
  * 작은 문제들은 서로 독립일 필요가 없음
* 플로이드 알고리즘(모든 정점 간의 최단 경로)
