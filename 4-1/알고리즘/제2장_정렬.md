# 2. 정렬

## 2.1 기본 개념

- 주어진 데이터를 값의 크기 순서에 따라 재배치하는 것
- 내부정렬
    - 전체 데이터를 주기억장치에 저장한 후 정렬을 수행하는 방식
- 안정적 정렬
    - 동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 상대적 위치가 정렬 후에도 그대로 유지되는 정렬

## 2.2 기초적인 정렬 알고리즘

### 2.2.1 선택 정렬

### (1) 개념과 원리

- 입력 배열에서 가장 작은 값부터 순서대로 선택해서 나열

### (2) 알고리즘

```kotlin
SelectionSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // (n-1)번 반복
min = i;
for (j=i+1; j < n; j++) // ①A[i..n-1]에서 최솟값 찾기
if (A[min] > A[j])
min = j;
A[i]와 A[min]의 자리바꿈; // ②최소값과 A[i]의 위치 교환
}
return (A);
}
```

### (3) 성능 및 특징

1. 시간 복잡도는 O(N^2)이다.
2. 입력 데이터의 순서에 민감하지 않다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.1]은 안정적인 정렬 알고리즘이 아니다.

### 2.2.2 버블 정렬

### (1) 개념과 원리

- 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식

### (2) 알고리즘

```kotlin
BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) // 단계: (n-1)번 반복
for (j=0; j < n-1; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) // ‘왼쪽 데이터 >오른쪽 데이터’이면
A[j]와 A[j+1]의 자리바꿈;
return (A);
}
```

### (3) 성능과 특징

1. 시간 복잡도는 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.2]를 개선해서 정렬 과정에서의 비교 횟수를 줄일 여지가 있다.
5. 입력 데이터의 상태에 따라 성능이 달라진다.
6. 선택 정렬에 비해 데이터의 교환이 많이 발생한다.

### 개선된 버블 정렬 알고리즘

- 각 루프의 반복 횟수를 줄여서 개선 가능
    - 처리 단계의 수
        - 자리바꿈이 발생하지 않으면 이미 정렬된 상태이므로 이후의 처리단계를 수행하지 않고 종료
        - 인접한 두 데이터의 비교 횟수
        - 각 단계에서 무조건 오른쪽/왼쪽 끝까지 이동하면서 인접한 두 데이터의 비교가 불필요 → 이미 제자리를 잡은 데이터에 대해서는 비교를 수행하지 않도록 함

```kotlin
Advanced_BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // 단계: 0, 1, ⋯, (n-2)
Sorted= TRUE;// 이미 정렬된 상태라고 가정
for (j=0; j < (n-1)-i; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) {
A[j]와 A[j+1]의 자리바꿈;
Sorted= FALSE;// 자리바꿈 발생 → 미정렬 상태
}
if (Sorted== TRUE) break;// 이미 정렬된 상태이므로 종료
} return (A);
}
```

- 시간 복잡도 O(n^2)
- 입력 데이터의 상태에 따라 성능이 달라짐

### 2.2.3 삽입 정렬

### (1) 개념과 원리

- 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 상태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식

### (2) 알고리즘

```kotlin
InsertionSort(A[ ], n)
{
for (i=1; i< n; i++) { // A[0] 정렬 부분; 1, ⋯, (n-1)까지 (n-1)번 반복
val= A[i]; // 미정렬 부분 A[i..n-1]의 첫 번째 데이터 선택
for (j=i; j > 0 && A[j-1] > val; j--) // 삽입할 위치 찾기
A[j] = A[j-1]; // 정렬 부분의 A[j-1]이 크면 뒤로 한 칸 이동
A[j] = val; // 찾아진 위치에 선택된 데이터 삽입
}
return (A);
}
```

### (3) 성능과 특징

1. 최악의 수행 시간은 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. 입력 데이터의 원래 순서에 민감하다.

### 2.2.4 셸 정렬

### (1) 개념과 원리

- 멀리 떨어진 데이터와의 비교·교환으로 한 번에 이동할 수 있는 거리를 늘려서 처리 속도 향상
- 하나의 입력 배열을 물리적으로 여러 개의 부분배열로 분할하지 않음
- 각 부분배열을 번갈아 가면서 미정렬 부분의 첫 번째 데이터를 뽑은 후 D만큼씩 떨어진 정렬 부분에서 제자리를 찾아서 삽입하는 방식

### (2) 알고리즘

```kotlin
ShellSort(A[ ], n)
{
for (D=n/2; D>=1; D=D/2) { // D: 부분배열의 개수 & 간격의 크기
for (i=D; i< n; i++) {
val= A[i];
for (j=i; j>=D&& A[j-D] > val; j=j-D)
A[j] = A[j-D];
A[j] = val;
}
}
return (A);
}
```

### (3) 성능과 특징

1. [알고리즘 2.5]에서 D를 계산하는 방식, 즉 사용하는 순열에 따라 성능이 달라진다.
2. 안정적이지 않은 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.

---
# 4강. 정렬 (2)

# 2.3 향상된 정렬 알고리즘

## 2.3.1 퀵 정렬

### (1) 개념과 원리

- 특정 데이터를 기준으로 주어진 배열을 2개의 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 피벗 :
    - 주어진 배열을 두 부분배열로 분할하는 기준이 되는 특정 데이터
        - 보통 주어진 배열의 첫 번째 데이터로 지정
- 피벗이 제자리를 잡도록 하여 정렬하는 방식
- 왼쪽 부분 배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값

### (2) 알고리즘

```kotlin
QuickSort(A[], n)
{
	if (n > 1) {
//	1. 피벗을 기준으로 두 부분배열로 분할
// pivot은 제자리를 잡은 피벗의 위치(인덱스)를 표시
pivot = Partition(A[0..n-1], n);

// 2. 왼쪽 부분배열에 대한 퀵 정렬의 순환 호출
QuickSort(A[0..pivot-1], pivot);

// 3. 오른쪽 부분배열에 대한 퀵 정렬의 순환 호출
QuickSort(A[pivot+1..n-1], n-pivot-1);
```

```kotlin
int Partition(A[], n)
{ 
	Left = 1;Right = n-1;
	while (Left < Right) {
		while (Left < n && A[Left] < A[0]) Left++;
		// 오른쪽으로 진행하면서 피벗 A[0]보다 큰 값의 위치를 찾음
		While (Right < 0 && A[Right] >= A[0] Right --;
		// 왼쪽으로 진행하면서 피벗 A[0]보다 작은 값의 위치를 찾음
		if (Left < Right)
			A[Left]와 A[Right]의 위치 교환
		else
			피벗 A[0]와 A[Right]의 위치 교환
			// 피벗과의 위치 교환 후 첫 번째 while문 종료
		}
		return (Right);
```

### (3) 성능과 특징

1. 분할 함수 Partition()의 성능은 세타(n)
2. 퀵 정렬의 수행시간은 분할되는 두 부분배열의 크기에 따라 달라진다.
3. 최약의 수행시간은 n^2 ( 배열이 항상 0:n-1 또는 n-1:0으로 분할되는 경우
4. 최선의 수행시간은 nlogn (n/2:n/2)
5. 평균 수행시간은 nlogn
6. 피벗 선택의 임의성만 보장되면 평균 수행시간을 보장
7. 제자리 정렬 알고리즘 (입력 배열 이외에 추가적인 저장 공간을 상수 개(Left, Right, tmp, n, pivot)만 사용
8. 안정적이지 않은 정렬 알고리즘
9. 분할정복 방법이 적용된 알고리즘

## 2.4.2 합병 정렬

### (1) 개념과 원리

- 주어진 베열을 동일한 크기의 두 부분배열로 분할하고, 각 부분배열에 순환적으로 합병 정렬을 적용하여 정렬시킨 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦

### (2) 알고리즘

```kotlin
MergeSort(A[], n) 
{
	if (n > 1) {
		Mid = n/2;
		B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid);
		// 왼쪽 부분배열의 순환 호출 - 크기 n/2인 정렬된 배열 반환
		C[0..n-Mid-1] = MergeSort(A[Mid..n-1], n-Mid);
		// 오른쪽 부분배열의 순환 호출 - 크기 n/2인 정렬된 배열 반환
		A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid);
		// 정렬된 두 부분배열 B[]와 C[]의 합병 : A[] = B[] + C[]
		}
	return (A);
}
```

```kotlin
Merge(B[], C[], n, m) 
{
	i = j = k = 0;
	while (i < n && j < m) 
	// 정렬된 부분배열 B[i]와 C[j]를 비교해서 작은 데이터를 A[k]에 복사
		if (B[i] <= C[j])
			A[k++] = B[i++]
		else A[k++] = C[j++];
	for (; i < n; i++) A[k++] = B[i];
	for (; j < m; j++) A[k++] = C[j];
	// 정렬된 부분배열 B[] 또는 C[]에 남아있는 모든 데이터를 A[]로 복사
	return (A[0..n+m01]);
}
```

### (3) 성능과 특징

1. 안정적인 정렬 알고리즘 (합병 과정에서 동일한 두 데이터에 대해서 항상 왼쪽 데이터를 먼저 선택함)
2. 제자리 정렬 알고리즘이 아님 (A[n] = B[n/2] + C[n/2] → 입력 크기 n만큼의 추가적인 공간을 요구)
3. 전형적인 분할정복 방법이 적용됨
4. 비순환적 방식의 합병 정렬 (비순환식도 구현 가능)