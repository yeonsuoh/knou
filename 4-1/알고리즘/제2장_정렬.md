# 2. 정렬

## 2.1 기본 개념

- 주어진 데이터를 값의 크기 순서에 따라 재배치하는 것
- 내부정렬
    - 전체 데이터를 주기억장치에 저장한 후 정렬을 수행하는 방식
- 안정적 정렬
    - 동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 상대적 위치가 정렬 후에도 그대로 유지되는 정렬

## 2.2 기초적인 정렬 알고리즘

### 2.2.1 선택 정렬

### (1) 개념과 원리

- 입력 배열에서 가장 작은 값부터 순서대로 선택해서 나열

### (2) 알고리즘

```kotlin
SelectionSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // (n-1)번 반복
min = i;
for (j=i+1; j < n; j++) // ①A[i..n-1]에서 최솟값 찾기
if (A[min] > A[j])
min = j;
A[i]와 A[min]의 자리바꿈; // ②최소값과 A[i]의 위치 교환
}
return (A);
}
```

### (3) 성능 및 특징

1. 시간 복잡도는 O(N^2)이다.
2. 입력 데이터의 순서에 민감하지 않다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.1]은 안정적인 정렬 알고리즘이 아니다.

### 2.2.2 버블 정렬

### (1) 개념과 원리

- 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식

### (2) 알고리즘

```kotlin
BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) // 단계: (n-1)번 반복
for (j=0; j < n-1; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) // ‘왼쪽 데이터 >오른쪽 데이터’이면
A[j]와 A[j+1]의 자리바꿈;
return (A);
}
```

### (3) 성능과 특징

1. 시간 복잡도는 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.2]를 개선해서 정렬 과정에서의 비교 횟수를 줄일 여지가 있다.
5. 입력 데이터의 상태에 따라 성능이 달라진다.
6. 선택 정렬에 비해 데이터의 교환이 많이 발생한다.

### 개선된 버블 정렬 알고리즘

- 각 루프의 반복 횟수를 줄여서 개선 가능
    - 처리 단계의 수
        - 자리바꿈이 발생하지 않으면 이미 정렬된 상태이므로 이후의 처리단계를 수행하지 않고 종료
        - 인접한 두 데이터의 비교 횟수
        - 각 단계에서 무조건 오른쪽/왼쪽 끝까지 이동하면서 인접한 두 데이터의 비교가 불필요 → 이미 제자리를 잡은 데이터에 대해서는 비교를 수행하지 않도록 함

```kotlin
Advanced_BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // 단계: 0, 1, ⋯, (n-2)
Sorted= TRUE;// 이미 정렬된 상태라고 가정
for (j=0; j < (n-1)-i; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) {
A[j]와 A[j+1]의 자리바꿈;
Sorted= FALSE;// 자리바꿈 발생 → 미정렬 상태
}
if (Sorted== TRUE) break;// 이미 정렬된 상태이므로 종료
} return (A);
}
```

- 시간 복잡도 O(n^2)
- 입력 데이터의 상태에 따라 성능이 달라짐

### 2.2.3 삽입 정렬

### (1) 개념과 원리

- 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 상태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식

### (2) 알고리즘

```kotlin
InsertionSort(A[ ], n)
{
for (i=1; i< n; i++) { // A[0] 정렬 부분; 1, ⋯, (n-1)까지 (n-1)번 반복
val= A[i]; // 미정렬 부분 A[i..n-1]의 첫 번째 데이터 선택
for (j=i; j > 0 && A[j-1] > val; j--) // 삽입할 위치 찾기
A[j] = A[j-1]; // 정렬 부분의 A[j-1]이 크면 뒤로 한 칸 이동
A[j] = val; // 찾아진 위치에 선택된 데이터 삽입
}
return (A);
}
```

### (3) 성능과 특징

1. 최악의 수행 시간은 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. 입력 데이터의 원래 순서에 민감하다.

### 2.2.4 셸 정렬

### (1) 개념과 원리

- 멀리 떨어진 데이터와의 비교·교환으로 한 번에 이동할 수 있는 거리를 늘려서 처리 속도 향상
- 하나의 입력 배열을 물리적으로 여러 개의 부분배열로 분할하지 않음
- 각 부분배열을 번갈아 가면서 미정렬 부분의 첫 번째 데이터를 뽑은 후 D만큼씩 떨어진 정렬 부분에서 제자리를 찾아서 삽입하는 방식

### (2) 알고리즘

```kotlin
ShellSort(A[ ], n)
{
for (D=n/2; D>=1; D=D/2) { // D: 부분배열의 개수 & 간격의 크기
for (i=D; i< n; i++) {
val= A[i];
for (j=i; j>=D&& A[j-D] > val; j=j-D)
A[j] = A[j-D];
A[j] = val;
}
}
return (A);
}
```

### (3) 성능과 특징

1. [알고리즘 2.5]에서 D를 계산하는 방식, 즉 사용하는 순열에 따라 성능이 달라진다.
2. 안정적이지 않은 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.