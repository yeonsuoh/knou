# 2. 정렬

## 2.1 기본 개념

- 주어진 데이터를 값의 크기 순서에 따라 재배치하는 것
- 내부정렬
    - 전체 데이터를 주기억장치에 저장한 후 정렬을 수행하는 방식
- 안정적 정렬
    - 동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 상대적 위치가 정렬 후에도 그대로 유지되는 정렬

## 2.2 기초적인 정렬 알고리즘

### 2.2.1 선택 정렬

### (1) 개념과 원리

- 입력 배열에서 가장 작은 값부터 순서대로 선택해서 나열

### (2) 알고리즘

```kotlin
SelectionSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // (n-1)번 반복
min = i;
for (j=i+1; j < n; j++) // ①A[i..n-1]에서 최솟값 찾기
if (A[min] > A[j])
min = j;
A[i]와 A[min]의 자리바꿈; // ②최소값과 A[i]의 위치 교환
}
return (A);
}
```

### (3) 성능 및 특징

1. 시간 복잡도는 O(N^2)이다.
2. 입력 데이터의 순서에 민감하지 않다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.1]은 안정적인 정렬 알고리즘이 아니다.

### 2.2.2 버블 정렬

### (1) 개념과 원리

- 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식

### (2) 알고리즘

```kotlin
BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) // 단계: (n-1)번 반복
for (j=0; j < n-1; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) // ‘왼쪽 데이터 >오른쪽 데이터’이면
A[j]와 A[j+1]의 자리바꿈;
return (A);
}
```

### (3) 성능과 특징

1. 시간 복잡도는 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. [알고리즘 2.2]를 개선해서 정렬 과정에서의 비교 횟수를 줄일 여지가 있다.
5. 입력 데이터의 상태에 따라 성능이 달라진다.
6. 선택 정렬에 비해 데이터의 교환이 많이 발생한다.

### 개선된 버블 정렬 알고리즘

- 각 루프의 반복 횟수를 줄여서 개선 가능
    - 처리 단계의 수
        - 자리바꿈이 발생하지 않으면 이미 정렬된 상태이므로 이후의 처리단계를 수행하지 않고 종료
        - 인접한 두 데이터의 비교 횟수
        - 각 단계에서 무조건 오른쪽/왼쪽 끝까지 이동하면서 인접한 두 데이터의 비교가 불필요 → 이미 제자리를 잡은 데이터에 대해서는 비교를 수행하지 않도록 함

```kotlin
Advanced_BubbleSort(A[ ], n)
{
for (i=0; i< n-1; i++) { // 단계: 0, 1, ⋯, (n-2)
Sorted= TRUE;// 이미 정렬된 상태라고 가정
for (j=0; j < (n-1)-i; j++) // 왼쪽에서 오른쪽으로 진행하는 경우
if (A[j] > A[j+1]) {
A[j]와 A[j+1]의 자리바꿈;
Sorted= FALSE;// 자리바꿈 발생 → 미정렬 상태
}
if (Sorted== TRUE) break;// 이미 정렬된 상태이므로 종료
} return (A);
}
```

- 시간 복잡도 O(n^2)
- 입력 데이터의 상태에 따라 성능이 달라짐

### 2.2.3 삽입 정렬

### (1) 개념과 원리

- 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 상태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식

### (2) 알고리즘

```kotlin
InsertionSort(A[ ], n)
{
for (i=1; i< n; i++) { // A[0] 정렬 부분; 1, ⋯, (n-1)까지 (n-1)번 반복
val= A[i]; // 미정렬 부분 A[i..n-1]의 첫 번째 데이터 선택
for (j=i; j > 0 && A[j-1] > val; j--) // 삽입할 위치 찾기
A[j] = A[j-1]; // 정렬 부분의 A[j-1]이 크면 뒤로 한 칸 이동
A[j] = val; // 찾아진 위치에 선택된 데이터 삽입
}
return (A);
}
```

### (3) 성능과 특징

1. 최악의 수행 시간은 O(N^2)이다.
2. 안정적인 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.
4. 입력 데이터의 원래 순서에 민감하다.

### 2.2.4 셸 정렬

### (1) 개념과 원리

- 멀리 떨어진 데이터와의 비교·교환으로 한 번에 이동할 수 있는 거리를 늘려서 처리 속도 향상
- 하나의 입력 배열을 물리적으로 여러 개의 부분배열로 분할하지 않음
- 각 부분배열을 번갈아 가면서 미정렬 부분의 첫 번째 데이터를 뽑은 후 D만큼씩 떨어진 정렬 부분에서 제자리를 찾아서 삽입하는 방식

### (2) 알고리즘

```kotlin
ShellSort(A[ ], n)
{
for (D=n/2; D>=1; D=D/2) { // D: 부분배열의 개수 & 간격의 크기
for (i=D; i< n; i++) {
val= A[i];
for (j=i; j>=D&& A[j-D] > val; j=j-D)
A[j] = A[j-D];
A[j] = val;
}
}
return (A);
}
```

### (3) 성능과 특징

1. [알고리즘 2.5]에서 D를 계산하는 방식, 즉 사용하는 순열에 따라 성능이 달라진다.
2. 안정적이지 않은 정렬 알고리즘이다.
3. 제자리 정렬 알고리즘이다.

---
# 4강. 정렬 (2)

# 2.3 향상된 정렬 알고리즘

## 2.3.1 퀵 정렬

### (1) 개념과 원리

- 특정 데이터를 기준으로 주어진 배열을 2개의 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 피벗 :
    - 주어진 배열을 두 부분배열로 분할하는 기준이 되는 특정 데이터
        - 보통 주어진 배열의 첫 번째 데이터로 지정
- 피벗이 제자리를 잡도록 하여 정렬하는 방식
- 왼쪽 부분 배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값

### (2) 알고리즘

```kotlin
QuickSort(A[], n)
{
	if (n > 1) {
//	1. 피벗을 기준으로 두 부분배열로 분할
// pivot은 제자리를 잡은 피벗의 위치(인덱스)를 표시
pivot = Partition(A[0..n-1], n);

// 2. 왼쪽 부분배열에 대한 퀵 정렬의 순환 호출
QuickSort(A[0..pivot-1], pivot);

// 3. 오른쪽 부분배열에 대한 퀵 정렬의 순환 호출
QuickSort(A[pivot+1..n-1], n-pivot-1);
```

```kotlin
int Partition(A[], n)
{ 
	Left = 1;Right = n-1;
	while (Left < Right) {
		while (Left < n && A[Left] < A[0]) Left++;
		// 오른쪽으로 진행하면서 피벗 A[0]보다 큰 값의 위치를 찾음
		While (Right < 0 && A[Right] >= A[0] Right --;
		// 왼쪽으로 진행하면서 피벗 A[0]보다 작은 값의 위치를 찾음
		if (Left < Right)
			A[Left]와 A[Right]의 위치 교환
		else
			피벗 A[0]와 A[Right]의 위치 교환
			// 피벗과의 위치 교환 후 첫 번째 while문 종료
		}
		return (Right);
```

### (3) 성능과 특징

1. 분할 함수 Partition()의 성능은 세타(n)
2. 퀵 정렬의 수행시간은 분할되는 두 부분배열의 크기에 따라 달라진다.
3. 최약의 수행시간은 n^2 ( 배열이 항상 0:n-1 또는 n-1:0으로 분할되는 경우
4. 최선의 수행시간은 nlogn (n/2:n/2)
5. 평균 수행시간은 nlogn
6. 피벗 선택의 임의성만 보장되면 평균 수행시간을 보장
7. 제자리 정렬 알고리즘 (입력 배열 이외에 추가적인 저장 공간을 상수 개(Left, Right, tmp, n, pivot)만 사용
8. 안정적이지 않은 정렬 알고리즘
9. 분할정복 방법이 적용된 알고리즘

## 2.4.2 합병 정렬

### (1) 개념과 원리

- 주어진 베열을 동일한 크기의 두 부분배열로 분할하고, 각 부분배열에 순환적으로 합병 정렬을 적용하여 정렬시킨 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦

### (2) 알고리즘

```kotlin
MergeSort(A[], n) 
{
	if (n > 1) {
		Mid = n/2;
		B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid);
		// 왼쪽 부분배열의 순환 호출 - 크기 n/2인 정렬된 배열 반환
		C[0..n-Mid-1] = MergeSort(A[Mid..n-1], n-Mid);
		// 오른쪽 부분배열의 순환 호출 - 크기 n/2인 정렬된 배열 반환
		A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid);
		// 정렬된 두 부분배열 B[]와 C[]의 합병 : A[] = B[] + C[]
		}
	return (A);
}
```

```kotlin
Merge(B[], C[], n, m) 
{
	i = j = k = 0;
	while (i < n && j < m) 
	// 정렬된 부분배열 B[i]와 C[j]를 비교해서 작은 데이터를 A[k]에 복사
		if (B[i] <= C[j])
			A[k++] = B[i++]
		else A[k++] = C[j++];
	for (; i < n; i++) A[k++] = B[i];
	for (; j < m; j++) A[k++] = C[j];
	// 정렬된 부분배열 B[] 또는 C[]에 남아있는 모든 데이터를 A[]로 복사
	return (A[0..n+m01]);
}
```

### (3) 성능과 특징

1. 안정적인 정렬 알고리즘 (합병 과정에서 동일한 두 데이터에 대해서 항상 왼쪽 데이터를 먼저 선택함)
2. 제자리 정렬 알고리즘이 아님 (A[n] = B[n/2] + C[n/2] → 입력 크기 n만큼의 추가적인 공간을 요구)
3. 전형적인 분할정복 방법이 적용됨
4. 비순환적 방식의 합병 정렬 (비순환식도 구현 가능)


---

# 5강. 정렬 (3)

# 1. 힙 정렬

## 힙 자료구조

- 힙 자료구조의 장점을 활용한 정렬
- 임의의 값 삽입과 최댓값 삭제가 쉬움

### 최대 힙 (heap)

- 완전 이진 트리
- 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같아야 함

## 힙의 구현

- 일차원 배열

## 힙의 장점

- 임의의 값의 삽입
- 최댓값 삭제
    - 최댓값 ↔ 마지막값
    - 최댓값 삭제
    - 힙 재구성

## 힙 정렬의 처리 과정

1. 1차원 배열을 힙으로 변환
2. 최댓값 삭제
3. 힙의 재구성
4. 2,3 반복

## 초기 힙 구축

- 1차원 입력 배열을 힙으로 변환하는 것
- 방법 1
    - 주어진 입력배열의 각 원소를 힙에 삽입하는 과정을 반복
- 방법 2
    - 주어진 입력 배열을 우선 완전 이진 트리로 만든 후, 각 노드에 대해 아래에서 위로 그리고 오른쪽에서 왼쪽으로 진행하면서 해당 노드의 아랫부분이 힙의 조건을 만족할 수 있도록 트리를 따라 내려가면서 자신의 자손 노드들과의 위치 교환을 계속해 나가는 방법

## 성능과 특징

- 최선, 최악, 평균 수행시간 → O(nlogn)
    - 초기 힙 생성, 최댓값 삭제 및 힙 재구성
        - 바깥 루프 → 입력 크기 n에 비례
        - 안쪽 루프 → 완전 이진 트리의 높이 logn에 비례
    - 안정적이지 않은 정렬 알고리즘
    - 제자리 정렬 알고리즘

# 2. 계수 정렬

## 정렬 알고리즘

### 비교 기반의 정렬 알고리즘

- 기본 성능 O(n^2) → 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬
- 향상된 평균 성능 O(nlogn) → 퀵 정렬, 합병 정렬, 힙 정렬
- 비교 기반 정렬 알고리즘 성능의 하한 → O(nlogn)
    - 아무리 빨라도 O(nlogn)보다 더 효율적인 알고리즘은 구할 수 없음

### 이미 얻어진 데이터 분포 정보를 활용하는 정렬 알고리즘

- 계수 정렬, 기수 정렬, 버킷 정렬
    - 선형 시간 O(n)이 가능

## 계수 정렬

### 주어진 데이터 중에서 자신보다 작거나 같은 값을 갖는 데이터의 개수를 계산하여 정렬할 위치를 찾아 정렬하는 방식

- 입력값이 어떤 작은 정수 범위 내에 있다는 것을 알고 있는 경우에 적용 가능
- k보다 작거나 같은 값을 갖는 데이터의 개수
    - 정렬 순서상 k의 마지막 위치
- 자신보다 작거나 같은 값을 갖는 데이터의 개수의 효율적인 계산 방법
    - 입력값의 범위 a~b에 해당하는 크기의 배열 COUNT[a..b]를 할당하고, 주어진 값들을 한 번 쭉 훑으면 각 입력값의 출현횟수의 누적값 계산이 가능

## 성능과 특징

- 입력값의 범위가 데이터의 개수보다 작거나 비례할 때 유용
    - 입력값의 범위를 k라고 할 때 O(n+k)  시간
    - k = O(n)이 되어야 선형시간 O(n)에 동작
- 안정적인 정렬 알고리즘
    - 입력 배열 A[]의 오른쪽의 것부터 뽑아서 결과 배열 B[]의 오른쪽에서부터 저장
- 제자리 정렬 알고리즘이 아님
    - 입력 배열 A[1..n] + (COUNT[a..b], B[1..n])
- 보편적이지 못한 정렬 알고리즘
    - 입력값의 범위를 미리 알아야 함 + 추가적인 배열이 필요

# 3. 기수 정렬

- 입력값을 자릿수별로 구분해서 부분적으로 비교하여 정렬하는 방식
- 주어진 데이터의 값을 자릿수별로 나누고, 각 자릿수에 대해 계수 정렬과 같은 안정적인 정렬 알고리즘을 적용하여 정렬
    - LSD (Least Significant Digit 기수 정렬 → 낮은 자리부터 높은 자리로 진행, Right to Left)
    - MSD (Most Significant Digit 기수 정렬 → 높은 자리부터 낮은 자리로 진행, Left to Right)

## 성능과 특징

- 입력 데이터의 자릿수가 상수일 때 유용
    - d 자릿수 n 개의 숫자들에 대해 계수 정렬을 적용하면 O(dn)
    - → 여기서 d를 입력 크기 n가 무관한 상수로 간주하면 O(n)
- 안정적인 정렬 알고리즘
    - 각 자릿수별로 안정적인 정렬 알고리즘을 적용하므로 기수 정렬도 안정적
- 제자리 정렬 알고리즘이 아님
    - 계수 정렬 적용 → 전체 데이터 개수와 진법 크기만큼의 추가 공간이 필요

# 4. 버킷 정렬

1. 주어진 데이터들의 값의 범위를 균등하게 나누어 여러 개의 버킷을 만든 뒤,
2. 각 데이터를 해당하는 버킷에 넣고,
3. 각 버킷을 삽입 정렬과 같은 안정적인 정렬을 수행한 후,
4. 버킷 순서대로 각 데이터를 나열하는 정렬 방식
- 입력값의 범위 내에서 값이 확률적으로 균등하게 분포될 때 선형시간에 동작

## 성능과 특징

- 입력 데이터의 값이 확률적으로 균등하게 분포할 때 유용
    - 버킷별 정렬 → 데이터들이 각 버킷에 균등하게 들어갈 때 효율적인 정렬이 가능
- 버킷의 개수가 입력 데이터의 개수에 비례해야 유용
    - 버킷의 개수를 n/k로 정하면 각 버킷에는 상수(k)개의 데이터가 존재
    - → 각 버킷을 상수 시간에 정렬 가능
    - → 선형 시간의 동작이 가능
- 안정적인 정렬 알고리즘
    - 데이터를 버킷에 넣을 때 그리고 각 버킷의 정렬 과정에서 상대적인 순서를 유지
- 제자리 정렬 알고리즘이 아님
    - 추가적인 저장 공간(BUCKET[]과 크기 n의 배열 B[])이 필요