# 6강 탐색(1)

- 탐색
    - 여러 개의 원소로 구성된 데이터에서 원하는 값을 갖는 원소를 찾는 것
        - 데이터의 형태 : 리스트, 트리, 그래프 등
        - 내부 탐색 vs 외부 탐색
        - 관련 연산 → 탐색 + (초기화, 삽입, 삭제)
- 탐색 방법
    - 리스트 형태
    - 트리 형태
    - 해시 테이블

## 1. 순차 탐색

- 리스트 형태로 주어진 원소들을 처음부터 하나씩 차례로(“순차”) 비교하면서 원하는 값을 갖는 원소를 찾는 방법

### 성능과 특징

- 탐색, 삭제 연산의 시간 복잡도 : O(n)
- 삽입 연산의 시간 복잡도 : O(1)
- 정렬되지 않고 크기가 작은 데이터에 적합
    - 모든 리스트 형태의 입력에 적용 가능 → 비정렬 데이터 탐색에 적합
    - 탐색과 삭제에 O(n) 시간 필요 → 데이터가 큰 경우에는 부적합

## 2. 이진 탐색

- 정렬된 리스트 형태로 주어진 원소들을 절반씩 줄여 가면서 원하는 값을 가진 원소를 찾는 방법
    - 분할정복 방법이 적용됨
- 이진탐색_초기화 연산
    - 주어진 배열이 정렬되어 있지 않으면 정렬 수행
- 이진탐색_삽입 연산
- 이진탐색_삭제 연산
- 이진 탐색을 연결 리스트로 구현하면
    - 연결 리스트 구조에서는 이진탐색 자체가 불가능
- 성능
    - 탐색 연산 → O(logn)
    - 초기화 연산 → (nlogn)
    - 삽입/삭제 연산 → O(n)
- 정렬된 리스트에 대해서만 적용 가능
- 삽입과 삭제가 빈번한 경우에는 부적합



## 3. 이진 탐색 트리

### 이진 트리

- 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 작다.

### 탐색 연산

- 루트 노드에서부터 시작해서 값의 크기 관계에 따라 트리의 경로를 따라 내려가면서 탐색 진행

### 삽입 연산

- 삽입할 원소를 탐색한 후, 탐색이 실패하면 해당 위치에 자식 노드로서 새 노드를 추가

### 삭제 연산

- 후속자 (successor, 계승자 노드)
- 어떤 노드의 바로 다음 키값을 갖는 노드
- 삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리
    - 자식 노드가 없는 경우
        - 위치 조절이 불필요
    - 자식 노드가 하나인 경우
        - 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따로 올림
    - 자식 노드가 2개인 경우
        - 삭제되는 노드의 후속자 노드를 삭제되는 노드의 위치로 올리고,
        - 후속자 노드를 삭제되는 노드로 취급하여 자식 노드의 개수에 따라 다시 처리

### 성능과 특징

- 탐색, 삽입, 삭제 연산의 시간 복잡도
    - 평균 수행시간 O(logn) - 모든 노드의 차수가 2인 경우 (리프 노드 제외)
    - 최악 수행시간 O(n) - 모든 노드의 차수가 1인 경우 (리프 노드 제외)
- 삽입/삭제 연산 시 기존 노드의 이동이 거의 발생하지 않음
- 원소의 삽입/삭제에 따라 경사트리 형태가 될 수 있음
    - 균형 탐색 트리
        - 2-3-4 트리, 레드-블랙 트리, B-트리

## 4. 2-3-4 트리

- 다음 성질을 만족하는 균형 탐색 트리
    - 2-노드 → 1개의 키와 2개의 자식을 갖는 노드
    - 3-노드 → 2개의 키와 3개의 자식을 갖는 노드
    - 4-노드 → 3개의 키와 4개의 자식을 갖는 노드
    - 각 노드의 한 키의 왼쪽 서브트리에 있는 모든 키값은 그 키값보다 작다.
    - 각 노드의 한 키의 오른쪽 서브트리에 있는 모든 키값은 그 키값보다 크다.
    - 모든 리프 노드의 레벨은 동일

### 삽입 연산

- 탐색 과정에서 4-노드를 만나면 항상 노드 분할을 우선 수행

### 성능과 특징

- 탐색, 삽입, 삭제 연산의 시간 복잡도 → O(logn)
- 삽입, 삭제가 일어나도 경사 트리가 되지 않음
- 2-3-4 트리를 그대로 구현하면 노드 구조가 복잡해서 이진 탐색 트리보다 더 느려질 가능성이 많음